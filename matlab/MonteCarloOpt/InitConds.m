alpha = 0.4;  % xf1/(xf1+xf2)

% parameters
arena_radius = 2.8;  % 1.85 for smaller arena (CHECK WHICH VALUE IS USED)
piece_comm_range = 0.35;
robot_comm_range = 0.6;
robot_speed = 0.128;
arena_size = 3*arena_radius^2*sqrt(3)/2;
timestep = 1.0;
% probability of encountering a piece
p_encounter = robot_speed*timestep*2*piece_comm_range/arena_size;
% probability of two robots encountering each other
p_encounter_robot = robot_speed*timestep*2*robot_comm_range/arena_size;

% Define the connectivity pattern
NComplexes = 12;
Connections = [1 2; 2 1; 3 4; 4 3; 5 6; 6 5; 7 8; 8 7; 9 10; 10 9; 11 12; 12 11];
NConnections = size(Connections,1);
% generate an initial distribution %
s = 60;
Xinit = s*[1 2 1 1 zeros(1,6)]';
Yinit = [Xinit(1)*Xinit(2); Xinit(5); Xinit(3)*Xinit(4); Xinit(6); Xinit(2)*Xinit(7); ...
         Xinit(9); Xinit(5)*Xinit(6); Xinit(7); Xinit(2)*Xinit(5); Xinit(8); ...
         Xinit(6)*Xinit(8); Xinit(10)];
% Define the desired occupancies %
x1 = 0.5; % independent
x2 = 2.5; % independent
x3 = 1; % independent
x5 = 0.5; % independent
x4 = x3;
x7 = x2-2*x1-x5;
xf1 = (Xinit(1)-x1-x5-x7-1)*alpha; % independent
xf2 = (Xinit(1)-x1-x5-x7-1)*(1-alpha); % independent
x8 = Xinit(1)-x1-x5-x7-xf1-xf2;
x6 = Xinit(3)-x3-x7-xf1-xf2;
Xdes = [x1 x2 x3 x4 x5 x6 x7 x8 xf1 xf2]';
Ydes = [x1*x2; x5; x3*x4; x6; x2*x7; xf1; x5*x6; x7; x2*x5; x8; x6*x8; xf2];

Y = [1     0     0     0     0     0     0     0     0     0     0     0; ...
     1     0     0     0     1     0     0     0     1     0     0     0; ...
     0     0     1     0     0     0     0     0     0     0     0     0; ...
     0     0     1     0     0     0     0     0     0     0     0     0; ...
     0     1     0     0     0     0     1     0     1     0     0     0; ...
     0     0     0     1     0     0     1     0     0     0     1     0; ...
     0     0     0     0     1     0     0     1     0     0     0     0; ...
     0     0     0     0     0     0     0     0     0     1     1     0; ...
     0     0     0     0     0     1     0     0     0     0     0     0; ...
     0     0     0     0     0     0     0     0     0     0     0     1];

% Nk = 0 (N is derived from the equation Y*K*Ydes = 0) 
% 4th row is same as 3rd row, so it's taken out
% N = [-Ydes(1) Ydes(2) zeros(1,10);...
%      -Ydes(1) Ydes(2) 0 0 -Ydes(5) Ydes(6) 0 0 -Ydes(9) Ydes(10) 0 0;...
%      0 0 -Ydes(3) Ydes(4) zeros(1,8);...
%      0 0 -Ydes(3) Ydes(4) zeros(1,8);...
%      Ydes(1) -Ydes(2) 0 0 0 0 -Ydes(7) Ydes(8) -Ydes(9) Ydes(10) 0 0;...
%      0 0 Ydes(3) -Ydes(4) 0 0 -Ydes(7) Ydes(8) 0 0 -Ydes(11) Ydes(12);...
%      0 0 0 0 -Ydes(5) Ydes(6) Ydes(7) -Ydes(8) 0 0 0 0;...
%      zeros(1,8) Ydes(9) -Ydes(10) -Ydes(11) Ydes(12);...
%      0 0 0 0 Ydes(5) -Ydes(6) zeros(1,6);...
%      zeros(1,10) Ydes(11) -Ydes(12)];
N = [-Ydes(1) Ydes(2) zeros(1,10);...
     0 0 -Ydes(3) Ydes(4) zeros(1,8);...
     0 0 0 0 -Ydes(5) Ydes(6) Ydes(7) -Ydes(8) 0 0 0 0;...
     zeros(1,8) Ydes(9) -Ydes(10) -Ydes(11) Ydes(12);...
     0 0 0 0 Ydes(5) -Ydes(6) zeros(1,6);...
     zeros(1,10) Ydes(11) -Ydes(12)];
  
ProjCol = N'*inv(N*N')*N;  % projects a vector onto the column space of N'
ProjNull = eye(NConnections,NConnections) - ProjCol; % projects a vector onto the null space of N
 
%Constraints;